
##### 单体模式

> 什么是单体模式？单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。

单体模式的优点是：
1. 可以用来划分命名空间，减少全局变量的数量。
2. 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。
3. 可以被实例化，且实例化一次。

```js
// 创建div
var createWindow = function () {
    var div = document.createElement("div");
    div.innerHTML = "我是弹窗内容";
    div.style.display = 'none';
    document.body.appendChild(div);
    return div;
};
// 创建iframe
var createIframe = function () {
    var iframe = document.createElement("iframe");
    document.body.appendChild(iframe);
    return iframe;
};
// 获取实例的封装代码
var getInstance = function (fn) {
    var result;
    return function () {
        return result || (result = fn.call(this, arguments));
    }
};
// 测试创建div
var createSingleDiv = getInstance(createWindow);
document.getElementById("Id").onclick = function () {
    var win = createSingleDiv();
    win.style.display = "block";
};
// 测试创建iframe
var createSingleIframe = getInstance(createIframe);
document.getElementById("Id").onclick = function () {
    var win = createSingleIframe();
    win.src = "http://cnblogs.com";
};
```



#####  代理模式
* 例子一(代理人替墙洞给奶茶送戒指)
```js
var MilkGirl = function (name) {
        this.name = name;
    }

//墙洞
var Ceo = function (girl) {
    this.girl = girl;
    //送结婚礼物，给奶茶
    this.sendMarriageRing = function (ring) {
        console.log("Hi "+ this.girl.name + ", ceo 送你一个礼物:"+ring)
    }
}

//京东CEO的经纪人，来代替送

var ProxyMan = function (girl) {
    this.girl = girl;
    this.sendGift = function (gift) {
        //代理模式负责本体对象的实例化
        (new Ceo(this.girl)).sendMarriageRing(gift)
    }
};

//初始化
var proxy = new ProxyMan(new MilkGirl("奶茶妹妹"));

proxy.sendGift("戒指")
```

* 例子二（加减法 缓存代理）
```js
// 计算乘法
var mult = function () {
    var a = 1;
    for (var i = 0, ilen = arguments.length; i < ilen; i += 1) {
        a = a*arguments[i];
    }
    return a;
};
// 计算加法
var plus = function () {
    var a = 0;
    for (var i = 0, ilen = arguments.length; i < ilen; i += 1) {
        a += arguments[i];
    }
    return a;
}
// 代理函数
var proxyFunc = function (fn) {
    var cache = {}; // 缓存对象
    return function () {
        var args = Array.prototype.join.call(arguments, ',');
        if (args in cache) {
            return cache[args]; // 使用缓存代理
        }
        return cache[args] = fn.apply(this, arguments);
    }
};
var proxyMult = proxyFunc(mult);
console.log(proxyMult(1,2,3,4)); // 24
console.log(proxyMult(1,2,3,4)); // 缓存取 24
var proxyPlus = proxyFunc(plus);
console.log(proxyPlus(1,2,3,4)); // 10
console.log(proxyPlus(1,2,3,4)); // 缓存取 10

```
