### 一、预备知识—程序的内存分配 

一个由C/C++编译的程序占用的内存分为以下几个部分   
1. `**栈区**（stack）—由编译器自动分配释放` ，存放函数的参数值，局部变量的值等。其操作方式`类似于数据结构中的栈`   
2. `**堆区**（heap）— 一般由程序员分配释放`，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是`类似于链表`  
3. 全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。\-程序结束后有系统释放   
4. 文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放 
5、程序代码区—存放函数体的二进制代码。

  

  

### 二、例子程序  

```
  //main.cpp
  inta = 0; //全局初始化区
  char*p1; //全局未初始化区
  main()
  {
  int b; //栈 
     char s[] = "abc"; //栈 
     char *p2; //栈  
     char *p3 = "123456"; //123456\0在常量区，p3在栈上。  
     static int c =0； //全局（静态）初始化区 
     p1 = (char *)malloc(10);  
      p2 = (char*)malloc(20);  
     //分配得来的10和20字节的区域就在堆区, 但是注意p1、p2本身是在栈中的 
     strcpy(p1,"123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。  
  } 

```

  

  

### 三、堆和栈的理论知识   
#### 3.1_申请后系统的响应

**栈**：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

注意这里，malloc分配失败会返回空指针，但new分配失败只会抛出异常,需要

```
catch( const bad_alloc& e ) {
           return-1;
}

```
  
#### 3.2_申请大小的限制
> 栈：在Windows下,`栈是向低地址扩展的数据结构，是一块连续的内存的区域`。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，由编译器决定栈的大小（一般1M/2M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。   
> 堆：`堆是向高地址扩展的数据结构，是不连续的内存区域`。这是由于系统是用`链表来存储的空闲内存地址的，自然是不连续的`，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

  

#### 3.3_申请效率的比较：

- 栈:`由系统自动分配，速度较快。但程序员是无法控制的`。 

- 堆: `由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便`.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

  

  

#### 3.4_堆和栈中的存储内容
- 栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 

- 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 

  

#### 3.5_存取效率的比较
```
chars[] = "abc"; //栈
    char*p3 = "123456"; //123456\0在常量区，p3在栈上。
```

abc是在运行时刻赋值的；而123456是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 

  
  

#### 3.6_小心内存泄漏

在堆上分配内存很容易造成内存泄漏，这是C/C++的最大的“克星”，如果你的程序要稳定，那么就不要出现MemoryLeak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包括calloc，realloc）时千万要小心。   
  
记得有一个UNIX上的服务应用程序，大约有几百的C文件编译而成，运行测试良好，等使用时，每隔三个月系统就是down一次，搞得许多人焦头烂额，查不出问题所在。只好，每隔两个月人工手动重启系统一次。出现这种问题就是MemeryLeak在做怪了，在C/C++中这种问题总是会发生，所以你一定要小心。   

对于malloc和free的操作有以下规则：   
1)配对使用，有一个malloc，就应该有一个free。（C++中对应为new和delete）   
2) 尽量在同一层上使用，不要malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。   
3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 

注：虽然现在的操作系统（如：UNIX和Win2k/NT）都有进程内存跟踪机制，也就是如果你有没有释放的内存，操作系统会帮你释放。但操作系统依然不会释放你程序中所有产生了MemoryLeak的内存，所以，最好还是你自己来做这个工作。（有的时候不知不觉就出现MemoryLeak了，而且在几百万行的代码中找无异于海底捞针，Rational有一个工具叫Purify，可能很好的帮你检查程序中的MemoryLeak）
